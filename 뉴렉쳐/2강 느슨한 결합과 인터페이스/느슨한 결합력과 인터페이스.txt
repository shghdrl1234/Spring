코드 수정을 없애고 DI를 위한 설정

UI => Service => Dao => DB
	S	 A1 => A
		 B1 => B 

위 상황에서 B1의 소스코드 수정이 필요하다. 이 때는 어떤 방법을 써야하는가?
- DAO의 B1의 코드를 수정하는 방법.

- B2라는 코드를 새로 추가해서 덮어쓰는 방법.
=> Service 코드를 수정해야한다.
ex) ptivate B1 b =new B1(); b.getData(); 를 // B1이라는 자료형으로 B1 객체생성,
    ptivate B2 b =new B2(); b.getData(); 로 Service의 소스코드를 바꿔야함. 
   // B2 자료형으로 B2객체 생성.

=> 수정에 대한 범위가 DAO에서 Service로 넘어왔을 뿐. 달라진 게 없음.

- 덮어쓰기를 하되, 가능한 한 수정안하는 방향으로 하는게 좋음.
수정을 하려면 소스코드가 필요하다. 프로그램 운영중 소스코드를 구해서 재배포하는 방법 중 위험성이 있을 수 도 있다.

S가 소스코드를 구해서 수정해야하만 B1에서 B2로 바꿀 수 있는 것은 결합력이 높은것이다.
=> B1을 B2로 바꾸려고하는데 S를 거쳐야하면 결합력이 높다고 볼 수 있다.

ptivate B1 b =new b.getData(); 이 코드에서
ptivate B2 b =new b.getData(); 이 코드로 변경할 때 어떻게 해야 결합력을 낮출 수 있을까?
(= 수정이 용이할까? , 소스코드 변경없이 바꿀 수 있을까?)
=> 결합력이 낮게 만들어 보자.

사용하는 자료형을 B1, B2 이런 것을 사용하지 않고 B<인터페이스>를 사용해준다.
ptivate B1 b = new B1(); b.getData(); 를 
ptivate B b = new B2(); b.getData(); 이렇게 바꿔준다. 

DAO에서 사용하는 Service가 달라진 것이 아니라, 함수 내부적인 코드가 달라진 것임.
클래스 이름을 거론할 필요없이, 기능에서만 사용할 수 있는 자료형으로 나타내는 것이 중요하다
=> 그것이 바로 인터페이스이다. 

그렇다면 다시, 처음으로 돌아가서 아래와 같은 형식이 될 것이다.
=> 결합력이 보다 낮아지게 됨.
UI => Service => Dao Interface => Dao => DB
	S		A	   A1  
		 	B	   B1  

ptivate B b = new B2(); b.getData();
여기서 또 문제가 있다. 여기서 B2라는 것을 생성할 때
Service와 DAO를 결합시켜주는 작업이 있는데 UI에서 진행하고,

B b = new B1(); Service.setB(b); 여기의 B1()을
객체 생성과 조립을 위한 외부설정(xml or annotation)에서 소스코드 없이 수정이 가능하도록 해준다.



